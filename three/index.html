<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three</title>

    <style>
        html, body { margin: 0; padding: 0; }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            transition: 0.2s opacity;
        }

        .faded {
            opacity: 0;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script>
    <script src="js/orbit.js"></script>
    <script src="js/T.js"></script>
    <script src="js/floors.js"></script>
    <script src="js/forms.js"></script>

    <script type="x-shader/x-vertex" id="vertexShader">

		varying vec3 vWorldPosition;

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	</script>

	<script type="x-shader/x-fragment" id="fragmentShader">

		uniform vec3 topColor;
		uniform vec3 bottomColor;
		uniform float offset;
		uniform float exponent;

		varying vec3 vWorldPosition;

		void main() {

			float h = normalize( vWorldPosition + offset ).y;
			gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );

		}

	</script>
</head>
<body>
    <div id="container"></div>
    <script>

        (function(){

            var world, camera, controls, scene, renderer;

            init();
            render();

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
            }

            function init() {

                world = new T();

                camera = world.camera;
                camera.position.x = -1000;
                camera.position.y = 750;
                camera.position.z = 500;

                scene = world.scene;

                renderer = world.renderer;
                renderer.setClearColor('#f2e8e8');

                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.damping = 0.5;
    			controls.addEventListener( 'change', render );

                var floorOffset = 0;

                floors.forEach(function(floor, i) {

                    var floorPlan = new THREE.Shape(),
                        floorHole,
                        floorGeo,
                        floorMesh;

                    // start it up
                    floorPlan.moveTo(floor.vertices[0][0], floor.vertices[0][1]);

                    floor.vertices.forEach(function(pt, j) {

                        if ( j > 0 ) floorPlan.lineTo(pt[0], pt[1]);

                    });

                    // close it off
                    floorPlan.lineTo(floor.vertices[0][0], floor.vertices[0][1]);

                    if ( floor.hole ) {
                        floor.hole.forEach(function(pt, j) {
                            floor.hole[j] = new THREE.Vector2(pt[0], pt[1]);
                        });

                        floorHole = new THREE.Path(floor.hole);

                        floorPlan.holes.push(floorHole);
                    }

                    floorGeo = new THREE.ExtrudeGeometry(floorPlan, {
                        amount: floor.height,
                        bevelSegments: 0
                    });

                    if ( i > 0 ) floorOffset += floors[i - 1].height;

                    floorMesh = world.mesh(floorGeo, new THREE.MeshLambertMaterial({
                        color: '#ddd'
                    }));

                    floorMesh.rotation.x = -Math.PI / 2;
                    floorMesh.position.y = floorOffset - 1;
                });


                // Tall building
                var building1 = [],
                    building1Height = 400;

                building1.push(Building.call(world, {
                    width: 200,
                    height: building1Height,
                    depth: 100,
                    x: 300,
                    z: -200,
                    color: '#ccc'
                }));

                // Group of neighboring buildings
                var neighbor = [],
                    building2Material = Material('#b97'),
                    building2_1 = world.mesh(
                        Box(60, 30, 20),
                        building2Material
                    ).x(140),
                    building2_2 = world.mesh(
                        Box(20, 30, 40),
                        building2Material
                    ).x(160).z(-30),
                    building2_3 = world.mesh(
                        Box(40, 15, 40),
                        Material('#666')
                    ).x(130).z(-30);
                neighbor.push(building2_1);
                neighbor.push(building2_2);
                neighbor.push(building2_3);

                function shapeFromPlan(plan) {
                    var thePlan = new THREE.Shape();
                    // start it up
                    thePlan.moveTo(plan[0][0], plan[0][1]);
                    plan.forEach(function(pt, j) {

                        if ( j > 0 ) thePlan.lineTo(pt[0], pt[1]);

                    });
                    // close it off
                    thePlan.lineTo(plan[0][0], plan[0][1]);
                    return thePlan;
                }

                var building3plan = [
                    [0, 0],
                    [25, 0],
                    [25, 40],
                    [0, 30]
                ];
                var building3 = world.mesh(
                        new THREE.ExtrudeGeometry(shapeFromPlan(building3plan), {
                            amount: 25,
                            bevelSegments: 0
                        }),
                        Material('#943')
                    ),
                    building3Roof = world.mesh(
                        new THREE.ExtrudeGeometry(shapeFromPlan(building3plan), {
                            amount: 2,
                            bevelSegments: 0
                        }),
                        Material('#eee')
                    );
                building3.position.x = 100;
                building3Roof.position.x = 100;
                building3.position.z = -60;
                building3Roof.position.z = -60;
                building3.rotation.x = -Math.PI / 2;
                building3Roof.rotation.x = -Math.PI / 2;
                building3.position.y = 0;
                building3Roof.position.y = 24;

                neighbor.push(building3);
                neighbor.push(building3Roof);

                neighbor.forEach(function(obj) {
                    obj.position.y -= 1;
                    obj.exclude = true;
                });

                function rotateAroundYAxis(obj, deg) {

                    var x = obj.position.x,
                        z = obj.position.z,
                        hypotenuse = Math.sqrt(x * x + z * z);

                    var curAngle = Math.atan( x / z ) * 180 / Math.PI,
                        newAngle = curAngle + deg;

                    newAngle = newAngle * Math.PI / 180;

                    obj.position.x = hypotenuse * Math.sin(newAngle);
                    obj.position.z = hypotenuse * Math.cos(newAngle);
                    obj.rotation.y += deg * Math.PI / 180;
                }

                building1.forEach(function(part) {
                    rotateAroundYAxis(part, 210);
                });

                // GROUND PLANE
                var plane = world.mesh(Box(100000, 1, 100000), Material('lambert', '#999')).y(-1);
                plane.exclude = true;

                var light = world.light();
                light.target = building1[0];
                light.position.set(1000, 2500, 2000);

                var light2 = world.light('#fff', 0.5, false);
                light2.target = building1[0];
                light2.position.set(-2000, 2500, -1000);

                var hemiLight = new THREE.HemisphereLight( '#57f', '#000', 0.15 );

                hemiLight.position.x = -200;
				hemiLight.position.y = 500;
				scene.add( hemiLight );

                // SKYDOME
				var vertexShader = document.getElementById( 'vertexShader' ).textContent,
                    fragmentShader = document.getElementById( 'fragmentShader' ).textContent;

				var uniforms = {
					topColor: 	 { type: "c", value: new THREE.Color( 0x0077ff ) },
					bottomColor: { type: "c", value: new THREE.Color( '#f2e8e8' ) },
					offset:		 { type: "f", value: 400 },
					exponent:	 { type: "f", value: 0.6 }
				}
				uniforms.topColor.value.copy( hemiLight.color );

                scene.fog = new THREE.Fog( 0xffffff, 1000, 20000 );
				scene.fog.color.copy( uniforms.bottomColor.value );

				var skyGeo = new THREE.SphereGeometry( 20000, 32, 15 );
				var skyMat = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
					side: THREE.BackSide
				} );

				var sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );

                // ----- resize
                window.addEventListener( 'resize', onWindowResize, false );

                // ----- animate
                animate();
            }

            var raycaster = new THREE.Raycaster(),
                mouse = new THREE.Vector2();

            var intersects = [];

            function render() {

                if ( raycaster ) {
                    raycaster.setFromCamera( mouse, camera );

                    intersects.forEach(function(intersect) {
                        if ( intersect.object && intersect.object.oldColor ) {
                            intersect.object.material.color = intersect.object.oldColor;
                        }
                    });
                    intersects = [];

                    // calculate objects intersecting the picking ray
                    raycaster.intersectObjects( scene.children ).forEach(function(intersect) {
                        intersects.push(intersect);
                    });

                    var closest = Infinity,
                        closestObj;
                    intersects.forEach(function(intersect) {
                        if ( intersect.distance < closest ) {
                            closest = intersect.distance;
                            closestObj = intersect;
                        }
                    });

                    var hypotenuse = Math.sqrt(camera.x() * camera.x() + camera.z() * camera.z());

                    if ( !closestObj.object.exclude ) {

                        var oldColor;
                        if ( closestObj.object && !closestObj.object.exclude ) {
                            oldColor = closestObj.object.oldColor || closestObj.object.material.color;
                            if ( oldColor ) {
                                closestObj.object.oldColor = oldColor;
                                closestObj.object.material.color = new THREE.Color( 0.666 * (1 + oldColor.r), 0.666 * (1 + oldColor.g), 0.666 * (1 + oldColor.b) );
                            }
                        }

                        closestObj.object.position.x -= camera.x() / hypotenuse;
                        closestObj.object.position.z -= camera.z() / hypotenuse;
                    }
                }

                renderer.render(scene, camera);
            }

            function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();
			}

            function uploadSnapshot() {
                var canvas = document.getElementsByTagName('canvas')[0];

                var url = 'http://gentle-stream-4461.herokuapp.com/upload/',
                    canvas = document.getElementsByTagName('canvas')[0],
                    dataURL = canvas.toDataURL().split(',')[1],
                    xhr = new XMLHttpRequest(),
                    data = JSON.stringify({ image: dataURL });

                xhr.open('POST', url, true);
                xhr.onload = function() {
                    console.log(xhr.responseText);
                };
                xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
                xhr.send(data);

                canvas.classList.add('faded');
                setTimeout(function(){
                    canvas.classList.remove('faded');
                }, 350);
            };

            window.addEventListener('keydown', function(e) {
                if ( e.keyCode === 13 ) uploadSnapshot();
            });



            // ----- RAYCASTER

            function onMouseMove( event ) {

            	// calculate mouse position in normalized device coordinates
            	// (-1 to +1) for both components

            	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
            	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1

                if ( raycaster ) {

                }

                render();
            }

            window.addEventListener( 'mousemove', onMouseMove, false );

            window.requestAnimationFrame(render);

        })();
    </script>
</body>
</html>
